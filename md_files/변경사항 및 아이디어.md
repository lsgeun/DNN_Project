# `2022년 07월 05일`

* ED_arrays, ED_array_i_j는 유클리드 거리 데이터에 대한 분석을 하기 위해서 필요한 변수임. 실제 거리를 계산하는 데에 있어서 필요한 변수임.
* normalization이나 min-max에서 필요함.

# `2022년 07월 06일`

1. n,m -> N, M로 바꿈

    for i in range(K) -> for k in range(K)로 바꿈.

2. DIstance_arrays의 shape을 (n, m, k)에서 (k, n, m)로 바꾸어야 함.

    -> 바꾸긴 했는데 그리 차이는 없어보임. 그냥 없애는 것도 방법. 대신 Distance를 람다 함수로 만드는게 가독성이나 수정에 용이해보임

3. random.randint 대신 np.random.randint로 바꿈.

    -> 데이터는 정수가 아니라 실수임. 이거 고쳐야 함.

4. 테스트 데이터 생산할 때 np.append 때문에 시간이 많이 걸림. 하지만 np.random.randint로 한 번에 데이터를 생산해여 np.append를 전혀 쓰지 않아서 몇 초 안으로 실행이 끝남.

    실제로 훈련 데이터나 테스트 데이터가 있다면 .npy 파일로 저장한 다음 이를 로드하면 되는데 sql이나 pickle보다 빠르다고 함.

5. 연습 2부터 4까지의 내용 practice.ipynb로 옮김. 연습 1은 삭제함

6. 거리를 구할 때, 넘파이 배열에 저장하는 방법 말고 딕셔너리에 람다함수를 저장해서 사용할 람다 metric으로 거리를 구할 수 있게 함.

    예를 들어, Distance['Taxi'] = lambda x, y: abs(x-y)

7. 이 ipynb을 기준으로 class를 만들기 위해 FMD_class.ipynb을 만듦

---

## `Note`

* Distance를 미리 저장해두면 빠르긴 하지만 Distance의 계산법을 바꾸었을 때 다시 저장하고 사용해야함. 또한, 소량이더라도 램을 잡아먹음.

- Distance를 저장하지 않고 람다 함수를 사용한다면 램을 잡아먹지 않지만 속도는 조금 느림. 하지만 distance의 계산법을 바꾸었을 때 바로 적용이 가능함.
- 데이터를 받을 때 평균을 어떻게 낼 거냐가 중요한 듯 만들어서 시뮬레이션 해봐야 할 듯
- 속도를 빠르게 하거나 저장 공간을 효율적으로 사용하는 방법을 찾아야 함.
- 데이터 입력 값이 어떻게 되었든 간에 거리 계산을 할 수 있어야 함.
    좀 애매해져서 거리를 어떻게 계산할지 생각해야함.

#  `2022년 07월 07일`

1. README.md의 내용을 변경사항.md로 옮김

2. 연습데이터를 실수로 만들었다. 예를 들어,

    `RFM_set = np.random.randint(random_start, random_end, size=(K, N, M), dtype ="int32")`

    `RFM_set = RFM_set - np.random.rand(K,N,M) # 이 부분을 추가하면 정수에서 실수로 됨`

    를 추가하여 특정 범위의 임의의 실수를 생성할 수 있었다. 이것으로 임의의 실수 데이터를 생성했다.

3. practice.ipynb에 대용량 넘파이 크기를 측정하는 셸을 만들었다. 예를 들어, 넘파이 하나의 크기가 3기가 이상인 데이터가 대용량 넘파이 크기라고 할 수 있다.

    1.부분을 지우고 넘버링을 없앴다.

    > 대용량 넘파이 크기를 따져보니 거리 계산 모델에 데이터를 저장하기보다 파일에서 데이터를 받아오는 식으로 모델을 구성해야겠다는 생각이 든다.
    >
    > 따라서, feature_map_distance에서 DIstance_arrays는 없애야 한다. 모델에 이게 있다면 한 모델의 크기가 몇 기가는 그냥 넘어간다. 그렇기 때문에 Distance_arrays의 자료구조를 바꾸는 식의 방법으로 속도를 높히는 것은 필요가 없다.
    >
    > 대신 Distance라는 람다 함수로 인덱스 간의 거리를 그때 그때 구하자.

4. feature_map_distance.ipynb에서 `2.2.1 정규화(normalization)에 대한 데이터 특징`을 없앴다. 코드 읽는데에 방해가 되기 때문이다.

5. feature_map_distance.ipynb에서 Distance_arrays 넘파이 배열로 거리를 구하는 방식에서 Distance 람다 함수로 거리를 구하도록 바꾸었다. 3.에서 언급한 것처럼 공간복잡도를 줄이기 위해서 시간복잡도를 늘렸다.

6. feature_map_distance.ipynb에서 pd.DataFrame로 히스토그램을 표현하니까 그래프로 그릴 필요가 없는 X가 표현이 되서 pd.DataFrame로 히스토그램을 표현하지 않고 plt.hist() 내장함수로 히스토그램을 표현했다.

7. feature_map_distance.ipynb에서 FMDC 출력을 추가했다. WFM_set_FMD.min()을 출력하면 된다. 확실히 min-max shift의 거리가 비교적 작다.

8. FMD_class.ipynb에서 fmd 클래스를 만들다가 생각난건데 훈련 데이터, 정분류 테스트 데이터, 오분류 테스트 데이터에 대한 파일로 저장될 넘파이 배열은 [레이어\]\[피처 맵 행\]\[피처 맵 열\]과 같은 형태를 띄어야 한다.

    이러한 데이터가 데이터의 총 개수(#훈련 데이터 + #정분류 테스트 데이터 + #오분류 테스트 데이터)만큼 있어야 한다. 이러한 데이터들이 종류별로 각 디렉토리에 저장되어야 하고 이 데이터를 접근할 수 있는 방법론이 있어야 한다.

    어떤 데이터에 대한 레이어의 출력들을 위와 같은 넘파이 배열로 파일을 저장하는 adapter가 필요할 것 같다. 레이어의 출력이 보통 3차원 배열이므로 이를 2차원으로 줄이는 방법이 여러 개 적용될 수 있을 것이다. 아마도 adapter에서 레이어의 출력을 파일로 만들어야 할 것 같다.

    그리고 연습 데이터 생성에 대한 부분을 조금 했다.

#  2022년 07월 08일

1. FMD_class.ipynb에서 fmd Class의 create_practice_data 메소드는 완성했음.

    연습 데이터인데 나중에 거리 계산하고자 하는 값들도 이와 같은 형태를 띄어야 할 것임.

2. FMD_class.ipynb에서 fmd Class 30가지 가량의 속성, get_data_info 메소드, get_FM_means 메소드, get_AM_means 메소드를 추가함.

    이는 feature_map_distance.ipynb의 아이디어를 차용해서 만든 것임.

3. feature_map_distance.ipynb에서 DAM_indexes의 일부만 가지고 거리를 계산하는 것을 고침

    `for i in range(len(DAM)):`

    ->`for i in range(len(nonzero_DAM[0])):`

4. FMD_class.ipynb에서 DAM_select, alpha_interval로 계산의 다양성을 높힘. 즉, 하이퍼 파라미터 2개를 추가함.

    DAM_select는 DAM가 골라지는 방식을 선택하는 것이고 alpha_slice은 alpha_min에서 alpha_max까지 몇 단계를 거쳐서 갈지 정하는 것임.

    그 외에도 FMD 계산 방법에 대한 하이퍼 파라미터를 추가할 예정임. 아직 메소드도 안 짜서 넣지 못함.
